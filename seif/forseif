package com.mycompany.oop;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.io.*;
import java.util.*;

public class OOP {

    public static void main(String[] args) {
        
        CSVIngestion csvIngestion = new CSVIngestion();
        String filePath = "SampleDataCSV.csv"; 
        List<List<String>> data = csvIngestion.csvImport(filePath);
        
        PropertyDataCleaner cleaner = new PropertyDataCleaner();
        
        cleaner.removeMissingValues(data);
        cleaner.removeDuplicates(data);
        cleaner.removeOutliers(data);
        cleaner.fixYear(data);

        // Now, inject the data into the respective objects
        csvIngestion.csvInject(data);
        
        System.out.println("Buyers List: " + csvIngestion.buyersList);
        System.out.println("Agents List: " + csvIngestion.agentsList);
        System.out.println("Houses List: " + csvIngestion.housesList);
        System.out.println("Locations List: " + csvIngestion.locationList);
        System.out.println("Units List: " + csvIngestion.unitsList);
        System.out.println("Townhouses List: " + csvIngestion.townhousesList);
        System.out.println("Development Sites List: " + csvIngestion.developmentSitesList);
        System.out.println("Transactions List: " + csvIngestion.transactionsList);

        
        //Exporting data to TXT files
        ExportData.saveToTXTFile("OutputTXT/units.txt", csvIngestion.unitsList);
        ExportData.saveToTXTFile("OutputTXT/agents.txt", csvIngestion.agentsList);
        ExportData.saveToTXTFile("OutputTXT/buyers.txt", csvIngestion.buyersList);
        ExportData.saveToTXTFile("OutputTXT/transactions.txt", csvIngestion.transactionsList);
        ExportData.saveToTXTFile("OutputTXT/houses.txt", csvIngestion.housesList);
        ExportData.saveToTXTFile("OutputTXT/dev.txt", csvIngestion.developmentSitesList);
        ExportData.saveToTXTFile("OutputTXT/townhouses.txt", csvIngestion.townhousesList);
        ExportData.saveToTXTFile("OutputTXT/locations.txt", csvIngestion.locationList);

        
        
        XLSIngestion xlsIngestion = new XLSIngestion();
        String filePath2 = "SampleDataXLSX.xlsx"; 
        List<List<String>> data2 = xlsIngestion.xlsImport(filePath2);
        // Now, inject the data into the respective objects

        cleaner.removeMissingValues(data2);
        cleaner.removeDuplicates(data2);
        cleaner.removeOutliers(data2);
        cleaner.fixYear(data2);
        
        
        xlsIngestion.xlsInject(data2);
        
        System.out.println("Buyers List: " + xlsIngestion.buyersList);
        System.out.println("Agents List: " + xlsIngestion.agentsList);
        System.out.println("Houses List: " + xlsIngestion.housesList);
        System.out.println("Locations List: " + xlsIngestion.locationList);
        System.out.println("Units List: " + xlsIngestion.unitsList);
        System.out.println("Townhouses List: " + xlsIngestion.townhousesList);
        System.out.println("Development Sites List: " + xlsIngestion.developmentSitesList);
        System.out.println("Transactions List: " + xlsIngestion.transactionsList);
        
               // Combine the lists from both CSV and XLS into a unified list for each type
        List<Buyer> BuyersList = new ArrayList<>();
        BuyersList.addAll(csvIngestion.buyersList);
        BuyersList.addAll(xlsIngestion.buyersList);

        List<Agent> AgentsList = new ArrayList<>();
        AgentsList.addAll(csvIngestion.agentsList);
        AgentsList.addAll(xlsIngestion.agentsList);

        List<House> HousesList = new ArrayList<>();
        HousesList.addAll(csvIngestion.housesList);
        HousesList.addAll(xlsIngestion.housesList);

        List<Location> LocationList = new ArrayList<>();
        LocationList.addAll(csvIngestion.locationList);
        LocationList.addAll(xlsIngestion.locationList);

        List<Unit> UnitsList = new ArrayList<>();
        UnitsList.addAll(csvIngestion.unitsList);
        UnitsList.addAll(xlsIngestion.unitsList);

        List<Townhouse> TownhousesList = new ArrayList<>();
        TownhousesList.addAll(csvIngestion.townhousesList);
        TownhousesList.addAll(xlsIngestion.townhousesList);

        List<DevelopmentSite> DevelopmentSitesList = new ArrayList<>();
        DevelopmentSitesList.addAll(csvIngestion.developmentSitesList);
        DevelopmentSitesList.addAll(xlsIngestion.developmentSitesList);

        List<Transaction> TransactionsList = new ArrayList<>();
        TransactionsList.addAll(csvIngestion.transactionsList);
        TransactionsList.addAll(xlsIngestion.transactionsList);
    
        
    }
}









package com.mycompany.oop;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;  // Add this import for Arrays.asList()
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Types;
import java.util.List;

public class ExportData {
          
    

    

    public static <T> void saveToTXTFile(String filePath, List<T> dataList) {
    try (FileWriter writer = new FileWriter(filePath)) {
        if (dataList == null || dataList.isEmpty()) {
            System.out.println("Data list is empty or null.");
            return;
        }

        // Write the header row dynamically, including nested Location fields separately
        T firstItem = dataList.get(0);
        Field[] fields = getAllFields(firstItem.getClass());

        for (int i = 0; i < fields.length; i++) {
            if (fields[i].getType().equals(Location.class)) {
                // Add location-specific headers
                writer.append("regionName,address,latitude,longitude,distance,postcode,councilArea,propertyCount");
            } else {
                writer.append(fields[i].getName());
            }

            if (i < fields.length - 1) {
                writer.append(",");
            }
        }
        writer.append("\n");

        // Write each object's data dynamically
        for (T item : dataList) {
            for (int i = 0; i < fields.length; i++) {
                fields[i].setAccessible(true); // Allow access to private fields
                try {
                    Object fieldValue = fields[i].get(item);

                    if (fieldValue instanceof Location) {
                        Location location = (Location) fieldValue;
                        writer.append(location.getRegionName()).append(",");
                        writer.append(location.getAddress()).append(",");
                        writer.append(String.valueOf(location.getLatitude())).append(",");
                        writer.append(String.valueOf(location.getLongitude())).append(",");
                        writer.append(String.valueOf(location.getDistance())).append(",");
                        writer.append(String.valueOf(location.getPostcode())).append(",");
                        writer.append(location.getCouncilArea()).append(",");
                        writer.append(String.valueOf(location.getPropertyCount()));
                    } else {
                        writer.append(fieldValue != null ? fieldValue.toString() : "null");
                    }

                    if (i < fields.length - 1) {
                        writer.append(",");
                    }
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
            writer.append("\n");  // New line after each row
        }

        System.out.println("Data has been successfully saved to " + filePath);
    } catch (IOException e) {
        System.out.println("Error writing to file: " + e.getMessage());
        e.printStackTrace();
    }
}



    // Helper method to get all fields of a class, including fields from parent classes
    private static Field[] getAllFields(Class<?> clazz) {
        // Start with the fields of the current class
        List<Field> allFields = new ArrayList<>();
        while (clazz != null) {
            allFields.addAll(Arrays.asList(clazz.getDeclaredFields()));
            clazz = clazz.getSuperclass(); // Move to the parent class
        }
        return allFields.toArray(new Field[0]); // Convert the list to an array
    }

}


    
    
    

    
    
    
    




