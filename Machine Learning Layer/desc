the parttttts work seperatelyyy , so if you wanna try anyy functionality , copy and paste and make any other thing a comment ,
after working on all parts , we will try to link them together, but for now lets work on them seperatey

the linear regression works fine, the only problem is that the results are not very fine because the relationship does not seem to be linear , which explains the low MSEEE

to run this part , PLEASEEEE ENSURE YOU USE THE DATASETS I INCLUDED HERE BECAUSE IT WILL NOT WORKKKK WITH SMALL DATASETS , SO USE THIS, THESE 
ARE THE 8300 LINES, THEY WILL DECREASE TO APPROXIMATELY 4000 LINES , 

IT IS FINE , YOUR PC WONT EXPLODE XD



use this code in the main to run LINEAR REGRESSION PLEASE:--------------------------------------------------------------------
   //LINEAR REGRESSION --------------------------------------------------------------------------
        // Display the explanation to the user
        // Create the main GUI frame
        JFrame frame = new JFrame("Linear Regression Model");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(500, 500);
        frame.setLayout(new BorderLayout());

        // Title label
        JLabel titleLabel = new JLabel("Welcome to the Linear Regression Model!", SwingConstants.CENTER);
        titleLabel.setFont(new Font("Arial", Font.BOLD, 16));
        frame.add(titleLabel, BorderLayout.NORTH);

        // Model Selection Panel
        JPanel modelPanel = new JPanel();
        modelPanel.setLayout(new GridLayout(5, 1));
        JLabel selectModelLabel = new JLabel("Select a model:");
        modelPanel.add(selectModelLabel);

        // Dropdown for model selection
        String[] models = {
            "House Price Prediction",
            "Units Price Prediction",
            "Townhouse Price Prediction"
        };
        JComboBox<String> modelComboBox = new JComboBox<>(models);
        modelPanel.add(modelComboBox);

        // Input panel for features
        JPanel inputPanel = new JPanel();
        inputPanel.setLayout(new GridLayout(4, 2));

        JLabel feature1Label = new JLabel("Feature 1 (Rooms):");
        JTextField feature1Field = new JTextField();
        inputPanel.add(feature1Label);
        inputPanel.add(feature1Field);

        JLabel feature2Label = new JLabel("Feature 2 (Bathrooms):");
        JTextField feature2Field = new JTextField();
        inputPanel.add(feature2Label);
        inputPanel.add(feature2Field);

        JLabel feature3Label = new JLabel("Feature 3 (Land Size):");
        JTextField feature3Field = new JTextField();
        inputPanel.add(feature3Label);
        inputPanel.add(feature3Field);

        JLabel feature4Label = new JLabel("Feature 4 (Parking Spots - Units only):");
        JTextField feature4Field = new JTextField();
        inputPanel.add(feature4Label);
        inputPanel.add(feature4Field);

        modelPanel.add(inputPanel);

        // Button to confirm model selection
        JButton selectButton = new JButton("Run Model");
        modelPanel.add(selectButton);

        frame.add(modelPanel, BorderLayout.CENTER);

        // Result Area (To display outputs)
        JTextArea resultArea = new JTextArea(10, 40);
        resultArea.setEditable(false);
        frame.add(new JScrollPane(resultArea), BorderLayout.SOUTH);

        // Button Click Action Listener
        selectButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                int modelChoice = modelComboBox.getSelectedIndex() + 1;

                // Load data based on user selection
                List<List<Object>> data = loadDataForModel(modelChoice);

                // Feature and target columns
                List<Integer> featureColumns = getFeatureColumnsForModel(modelChoice);
                int targetColumnIndex = getTargetColumnForModel(modelChoice);

                // Instantiate and fit the Linear Regression model
                LinearRegression model = new LinearRegression();
                model.linearRegression(data, featureColumns, targetColumnIndex);

                // Prepare test data for evaluation
                List<Object> actualTargetValues = new ArrayList<>();
                for (List<Object> row : data) {
                    actualTargetValues.add(row.get(targetColumnIndex));
                }

                double mse = model.evaluate(actualTargetValues);

                // Get user input values
                try {
                    double feature1 = Double.parseDouble(feature1Field.getText());
                    double feature2 = Double.parseDouble(feature2Field.getText());
                    double feature3 = Double.parseDouble(feature3Field.getText());
                    double feature4 = feature4Field.getText().isEmpty() ? 0.0 : Double.parseDouble(feature4Field.getText());

                    // Prepare user input for prediction
                    List<Object> userInput;
                    if (modelChoice == 2) {
                        // Model 2 has an extra feature (parking spots)
                        userInput = Arrays.asList(feature1, feature2, feature4, feature3);
                    } else {
                        userInput = Arrays.asList(feature1, feature2, feature3);
                    }

                    List<List<Object>> testInput = Collections.singletonList(userInput);
                    List<?> predictions = model.predict(testInput);

                    // Display results in the text area
                    resultArea.setText("Model Selected: " + models[modelChoice - 1] + "\n");
                    resultArea.append("Mean Squared Error (MSE): " + mse + "\n");
                    resultArea.append("Model coefficients are printed in the console.\n");
                    resultArea.append("Predicted Value: " + predictions.get(0) + "\n");

                } catch (NumberFormatException ex) {
                    resultArea.setText("Error: Please enter valid numerical values for features.");
                }
            }
        });

        frame.setVisible(true);
    }

    // Method to load data dynamically based on the model choice
    private static List<List<Object>> loadDataForModel(int modelChoice) {
        List<List<Object>> data = new ArrayList<>();
        try {
            List<Object> rooms;
            List<Object> bathrooms;
            List<Object> landSize;
            List<Object> parkingSpots = new ArrayList<>();
            List<Object> prices;

            switch (modelChoice) {
                case 1: // House Price Prediction
                    // Fetch columns for House model
                    rooms = DataExploration.fetchColumn("houses", "rooms");
                    bathrooms = DataExploration.fetchColumn("houses", "bathrooms");
                    landSize = DataExploration.fetchColumn("houses", "landsize");
                    prices = DataExploration.fetchColumn("transactions", "price");

                    // Construct the rows for House model
                    for (int i = 0; i < rooms.size(); i++) {
                        List<Object> row = new ArrayList<>();
                        row.add(rooms.get(i));        // Feature 1: Rooms
                        row.add(bathrooms.get(i));    // Feature 2: Bathrooms
                        row.add(landSize.get(i));     // Feature 3: Land Size
                        row.add(prices.get(i));       // Target: Price
                        data.add(row);
                    }
                    break;

                case 2: // Units Price Prediction
                    // Fetch columns for Units model (with parking spots)
                    rooms = DataExploration.fetchColumn("units", "rooms");
                    bathrooms = DataExploration.fetchColumn("units", "bathrooms");
                    landSize = DataExploration.fetchColumn("units", "landsize");
                    parkingSpots = DataExploration.fetchColumn("units", "parkingSpot");
                    prices = DataExploration.fetchColumn("transactions", "price");

                    // Construct the rows for Units model
                    for (int i = 0; i < rooms.size(); i++) {
                        List<Object> row = new ArrayList<>();
                        row.add(rooms.get(i));        // Feature 1: Rooms
                        row.add(bathrooms.get(i));    // Feature 2: Bathrooms
                        row.add(parkingSpots.get(i)); // Feature 3: Parking Spots
                        row.add(landSize.get(i));     // Feature 4: Land Size
                        row.add(prices.get(i));       // Target: Price
                        data.add(row);
                    }
                    break;

                case 3: // Townhouse Price Prediction
                    // Fetch columns for Townhouse model
                    rooms = DataExploration.fetchColumn("townhouses", "rooms");
                    bathrooms = DataExploration.fetchColumn("townhouses", "bathrooms");
                    landSize = DataExploration.fetchColumn("townhouses", "landsize");
                    prices = DataExploration.fetchColumn("transactions", "price");

                    // Construct the rows for Townhouse model
                    for (int i = 0; i < rooms.size(); i++) {
                        List<Object> row = new ArrayList<>();
                        row.add(rooms.get(i));        // Feature 1: Rooms
                        row.add(bathrooms.get(i));    // Feature 2: Bathrooms
                        row.add(landSize.get(i));     // Feature 3: Land Size
                        row.add(prices.get(i));       // Target: Price
                        data.add(row);
                    }
                    break;

                default:
                    System.out.println("Invalid model choice.");
            }
        } catch (Exception e) {
            System.err.println("Error loading data: " + e.getMessage());
        }

        return data;
    }

    // Method to return feature column indices based on the model
    private static List<Integer> getFeatureColumnsForModel(int modelChoice) {
        switch (modelChoice) {
            case 1: return Arrays.asList(0, 1, 2);  // House: rooms, bathrooms, landsize
            case 2: return Arrays.asList(0, 1, 2, 3);  // Units: rooms, bathrooms, parkingSpot, landsize
            case 3: return Arrays.asList(0, 1, 2);  // Townhouse: rooms, bathrooms, landsize
            default: return new ArrayList<>();
        }
    }

    // Method to get the target column index for the selected model
    private static int getTargetColumnForModel(int modelChoice) {
        switch (modelChoice) {
            case 1: return 3;  // price column
            case 2: return 4;  // price column
            case 3: return 3;  // price column
            default: return 3;
        }
    }
